<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>JsTest</title>
		<script type="text/javascript">
//			var arr=[33,43,35,34,63,345,2,424,234,32,2423,424,13];
//			for(var b=1;b<arr.length;b++){
//			for(var i=0;i<arr.length;i++){
//				if(arr[i]>arr[i+1]){
//					a=arr[i];
//					arr[i]=arr[i+1];
//					arr[i+1]=a;
//				}
//			}
//			}
//			document.write(arr);
//arr.reverse()数组颠倒
//arr.sort();数组排序，默认按照字符串升序排序
//function compare(a,b){return a-b}; 升序排序
//function compare(a,b)(return -(a-b)) 降序排序1》2》3》4，正好反过来 不是很理解
//	var arr=[33,43,35,34,63,345,2,424,234,32,2423,424,13];
//	function compareASE(a,b){
//		return a-b;
//	}
//	function compereeDESC(a,b){
//		return -(a-b);
//	}
//	function sortASE(){
//		arr.sort(compareASE);
//		console.log(arr.toSting());
//	}
//	function sortDESC(){
//		arr.sort(compareDESC);
//		console.log(arr.toSting());
//	}
//进栈和出栈;栈只能在一端出去和进入,另一端封闭
//栈操作:结尾入栈出栈:元素下标始终不变
//开头入栈出栈操作,所有元素下边随入栈和出栈的变化而变化
//入栈:arr.push();          arr.unshift(值1,---);
//出栈:var last=arr.pop();  var first=arr.shift();

//	var bus=[];
//	for(var i=1;i<=5;i++){
//		bus.push("乘客"+i);
//	}
//	document.write(bus+"<br>");
////	下车
//	while(bus.length>0){
//		var customer=bus.pop();
//		document.write(customer+"下车"+"<br>");
//	}
//	document.write(bus+"<br>");
//	var bus=[];                  //入栈操作
//	for(var i=1;i<=5;i++){
//		bus.unshift("乘客"+i);
//	}
//	document.write(bus+"<br>");
//		for(var i=1;i<=5;i++){	//出栈操作
//		bus.push("乘客"+i);
//	}
//	document.write(bus+"<br>");
//十进制转化为二进制
//一个目的:了解push存储
//	var bin=[];
//	var num=131;
//	while(num!=0){
//		bin.push(num%2);
//		num=parseInt(num/2);  //利用parseInt保留整数部分
//	}
//	bin.reverse();            //将数据翻转
//	document.write(bin.join(""));   //字符串拼接
//队列:先进先出，后进后出
//五个人和你抢手机，但是只有五部手机
//		var count=5;//共有五部手机
//		var queue=[];
//		for(var i=1;i<=5;i++){
//			queue.push("顾客"+i);
//		}//先后来了五个顾客
//		queue.push("小明");
//		queue.push("你");//最后你来了排队
//		document.write("当前排队的顾客:"+queue+"<br>");
//		//列出队列的每一个人，表示卖出一部手机
//		while(count>0){
//			var customer=queue.shift();
//			document.write(customer+"抢购成功<br>");
//			count--;
//		}//卖完手机里面，剩下的人就是没有抢到的人
//		document.write(queue+"没有抢上");
//二维数组
//1.定义一个规整的二维数组
//		var arr1=[[11,12,13],[21,22,23],[31,32,33]];
//2.定义一个不规整的二维数组
//		var arr2=new Array();
//		arr2[0]=[101];
//		arr2[1]=[201,202];
//		arr2[2]=[301,302,303];
//定义一个类似表格一样的二维数组表
//		var arr3=new Array();
//		arr3[0]=new Array(101,'jesse','2010-10-1');
//		arr3[1]=new Array(102,'ruihan','2010-10-1');
//		arr3[2]=new Array(103,'zhenyu','2010-10-1');
//访问数组的下标
//	arr[父数组中的下标][子数组中的下标];
//arr1[1][1]是指的是第一个元祖的第一个元素
//		var arr1=[[11,12,13],[21,22,23],[31,32,33]];
//		document.write(arr1[1][1]);
//写一个二维数组，存储省市，做到省市联动
//		var provs=['北京市','天津市','山东省'];
//		var cities=[
//		/*[0]*/ ['朝阳区','海淀区','东城区'],
//		/*[1]*/['南开区','和平区','河东区'],
//		/*[2]*/['德州市','济南市','青岛市','烟台市','济宁市','菏泽市']
//		];
//		function getCitiesByprov(prov){
//			//如何确定prov在provs中的下标？
//			var index;
//			for(var i=0;i<provs.length;i++){
//					if(prov==provs[i]){
//						index=i;
//						break;
//					}
//			}
//			if(index!==undefined){
//				var arr=cities[index];
//				for(var i=0;i<arr.length;i++){
//					console.log(arr[i]);
//				}
//			}
//		}
//		
//2017.11.24城市二级联动
//	var city=['山东省','北京市','天津市'];
//	var group=[
//		['济宁','德州','青岛'],
//		['顺义区','大兴区','天安门'],
//		['和平区','南开区','滨海新区']
//	];
//	function getcitybygroup(citys){
//		var index;
//		for(var i=0;i<=city.length;i++){
//			if(citys==city[i]){
//				index=i;
//				break;
//			}
//		}
//		if(index!=undefined){
//			console.log(group[index].toString())
//		}
//	}
//HTML代码：
//	<button onclick="getcitybygroup('天津市')">天津市</button>
//	<button onclick="getcitybygroup('山东省')">山东省</button>
//	<button onclick="getcitybygroup('北京市')">北京市</button>
//使用关联数组进行查找——>常用的方法,关系数组必须用var group={}来定义
//	var group={
//		'山东省':['济宁','德州','青岛'],
//		'北京市':['顺义区','大兴区','天安门'],
//		'天津市':['和平区','南开区','滨海新区']
//	};
//	function getcitytogroup(citys){
////		var index;
//		console.log(group[citys].toString());
//	}
//	<button onclick="getcitytogroup('天津市')">天津市</button>
//	<button onclick="getcitytogroup('山东省')">山东省</button>
//	<button onclick="getcitytogroup('北京市')">北京市</button>
//遍历数组里面的小数组  通过for循环遍历二维数组，很重要的
//	var group=[
//		/*0*/['济宁','德州','青岛'],
//		/*1*/['顺义区','大兴区','天安门'],
//		/*2*/['和平区','南开区','滨海新区']
//	];
//	for(var n=0;n<group.length;n++){
//		for(var i=0;i<group[n].length;i++){
//			document.write(group[n][i]);
//		}
//	}
//js必备的内置对象，内置对象是ECMAscript标准以及定义好的，由浏览器厂商已经实现的标准对象
//内置对象中封装了专门的数据和操作数据常用的API
//JavaScript中内置对象列表有十个，分别是：
//String，Boolean，Number，Array，Data，Math、Error、Function、Object、Global
//包装类型String、Number、Boolean：专门封装原始类型的数据，并提供对数据常用操作的内置对象
//why？因为要让原始类型的数据也可以像引用类型一样，拥有方法和属性
//什么时候用包装类型？只要用原始类型的数据调用方法或者访问属性时，js引擎都会自动创建对应的包装类型对象
//方法调用完，包装类型对象会自动释放
//String 对象用于处理文本字符串
//创建原始类型字符串变量
//var stuName='Smith'  //直接引用
//var gender='男';	   //直接引用
//var priceString=String(150.5);  //转换类型	
//创建引用类型字符串对象：
//var carType=New String('bmw528LI');//自己创建的，因为加New了
//String的包装类型
//str.length：返回str字符串中的字符个数
//str.toLowerCase()方法返回字符串的完全小写格式
//str.toUpperCase()方法返回字符串的完全大写形式
//	var str="Hello,World";
//	str=str.toLowerCase();
//	str1=str.toUpperCase();
//	document.write(str+str1);
//输出hello,world HELLO,WORLD 需要注意的是，转换完必须用一个字符接收，不接收的话参数传不过来
//字符串的内容一旦创建，不可以修改，不可以修改元字符串
//如果修改，必须创建新字符串，然后替换结果，保存新值，只要调用字符串的api，必须用新的变量接收返回值
//字符串以上必须记住，面试必考
//字符串API的学习;字符串的底层都是字符实现的
//		var a='hello';
//		console.log(a.length);//输出5  5个字符
//返回指定位置的字符:var char=str.charAt(index); //在index位置的char，字符
//输入身份证号输出性别
//		var pid="371471194710040056";
//		var char=pid.charAt(pid.length-2);
//		console.log(char%2==0?"女":"男");
//编码和转码Uncode
//	input=prompt("请输入需要转换的");
//	var result=[];
//	for(var i=0;i<input.length;i++){
//		result.push(input.charCodeAt(i));
//	}
//	document.write("你输入的字符:"+input+"---"+"转换后的字符:"+result.join(""));
//转换时候5位数字，不足五位的用00000填充
//	input=prompt("请输入需要转换的");
//	var result=[];
//	for(var i=0;i<input.length;i++){
//		var num=input.charCodeAt(i);
//		if(num<10000){//不足五位的都补齐五位
//			var arr=[0,0,0,0,0];
//			var code=num+"";  //将num转化为String
//			var start=5-code.length;
//				for(var n=0;n<code.length;n++){
//					arr[start]=code[n];
//					start++;
//				}
//				num=arr.join("");
//		}
//		result.push(num);
//	}
//	document.write("你输入的字符:"+input+"---"+"转换后的字符:"+result.join(""));

//转换时候5位数字，不足五位的用00000填充  ，外加解码
//	input=prompt("请输入需要转换的");
//	var result=[];
//	for(var i=0;i<input.length;i++){
//		var num=input.charCodeAt(i);
//		if(num<10000){//不足五位的都补齐五位
//			var arr=[0,0,0,0,0];
//			var code=num+"";  //将num转化为String
//			var start=5-code.length;
//				for(var n=0;n<code.length;n++){
//					arr[start]=code[n];
//					start++;
//				}
//				num=arr.join("");
//		}
//		result.push(num);
//		var c;
//		c=result.join("");
//	}
//	document.write("你输入的字符:"+input+"---"+"转换后的字符:"+c);
//	var b=[];
//	for(var i=0;i<c.length;i+=5){               //五位一组
//		var code=c.substring(i,i+5);			//截取五位
//		b.push(String.fromCharCode(code));		//入栈操作
//	}
//	var d=b.join("");
//	document.write("<br>转换后的字符串:"+d);

//按规律分割字符串    重点 面试会用
//分割后必须返回一个新的字符串，不然不能用

	//字符串优化定律
	//频繁对字符串+=，要用数组代替！！！！及其重要
	//step1：每个子字符串放入数组
	//step2：join("")拼接数组原色
	//用+"" 连接空字符串的方法效率是最高的，比toString的方法执行效率高
	//字符串的三大操作定律  1，查找关键字 2，替换关键 3， 获取子字符串
	//1,查找关键字 返回的是关键字所在的位置，否则是-1
	//var index=str.indexOf("关键字");  永远只找一个关键字，默认只能从0位置开始
	//重载：var index=str.indexOf("关键字"，from);  from开始查找的位置;
//	var str="今天是周五非常的开心周五";
//	var index=str.indexOf("周五");
//	console.log("位置："+index+"发现关键字");
//	var index=str.indexOf("周五",index+1);
//	console.log("位置："+index+"发现关键字");  
//	输出:位置：3发现关键字    位置：10发现关键字
//优化:indexOf()都用以下套路  必须记住
//	var str="今天是周五非常的开心周五";
//	var index=-1;
//	while((index=str.indexOf("周五",index+1))!=-1){  //index+1是表示从上一次找到的位置开始，继续下一个
//		console.log("位置"+index+"发现关键字");
//	} 
//备注:var index=str.lastIndexOf("关键字"，from); 是从后面往前面找
//	   var index=str.IndexOf("关键字"，from);     是从前面往后面找

//	var str="今天是周五非常的开心周五";
//	var index=str.length;
//	while((index=str.lastIndexOf("周五",index-1))!=-1){  //index+1是表示从上一次找到的位置开始，继续下一个
//		console.log("位置"+index+"发现关键字");
//	} 
//字符串从后面往前面查找是需要修改两个地方，
//1：index+1变为index-1，因为一直往后
//2：var index=-1 变成 var index=str.length; 因为是从最大的长度开始
//字符串的截取操作 
//var subStr=str.slice(start,end);  含头不含尾
//用法同substring(java语言是substr,js中是slice)   唯一差别slice不支持-1
//如果省略后面的字符，就会把所有的都会截取
//  var str="345681994412270088";
//  var subStr=str.slice(5,8+1);
//  var subStr1=str.slice(-12-1,-9);   //从后面开始
//  document.write("你的出生年份是"+subStr);
//  document.write("你的出生年份是"+subStr1);
//取得每个字母的首字母，然后转大写	
//	var str="you can you up";
//	var words=str.split(" ");  //按照" "空格开始分割
//	for(var i=0;i<words.length;i++){
//		//取每个单词的首字母
//		words[i]=words[i][0].toUpperCase()+words[i].substr(1);//取低于个元素，开头第一个字母大写
//	}
//	str=words.join(" ");
//	document.write(str);

//判断一个字符串的数量:返回数字的个数，字母的个数，英文的个数
//根据你unicode范围
// 48-57 		       是0-9是数字字符
//65-90  			A-Z的范围
//97-122  			a-z是小写字母
//19968-40869     	汉字的范围
//	var str="选购AppleCare+，延保2年";
//	var engCount=0;
//	var numCount=0;
//	var chsCount=0;
//	var other=0;
//	var num1=str.charCodeAt();
//	for(var i=0;i<str.length;i++){
//		var num=str.charCodeAt(i);
//		if(num>=19968&&num<=40869){
//			chsCount++;
//		}else if((num>=65&&num<=90)||(num>=97&&num<=122)){
//			engCount++;
//		}else if(num>=48&&num<=57){
//			numCount++;
//		}else{
//			other++;
//		}
//	}
//	document.write("原字符是:"+str+
//	"<br>转化成Unicode编码是:"+num1+
//	"<br>汉字是:"+chsCount+
//	"<br>英文字符是:"+engCount+
//	"<br>数字是:"+numCount+
//	"<br>其他是:"+other);
//  模式匹配 :可以设置查找的规则或者是替换规则
//何时使用模式匹配:要查找的关键字可能发生有规律的的变化
//如何使用模式匹配:1,先定义模式:/关键字/模式    注意不加双引号
//var reg=/no/i;    no是要查找的元素，i表示忽略大小写,g表示全局作用替换可以是中文使用
//String类型中，提供了专门支持模式匹配的API
//按模式替换关键字: str=str.replace(reg,"新的值");  变量必须回传
//	var str="No zuo no die";
//	var reg=/no/ig;     //加上i可以忽略大小写，如果不加，则匹配小写，g全部替换
//	str=str.replace(reg,"yes");
//	document.write(str);
//匹配  match(value/regexp)方法可以在字符串内检索指定的值，或找到一个或多个与正则表达式匹配的子串
//任何情况下，返回如果是数组的话，要加s 
//缺陷的地方：可以返回关键字，但是不能看到地址
//如果没有找到，则返回null
//		var str="No zuo no die";
//		var reg=/no/ig;     //加上i可以忽略大小写，如果不加，则匹配小写，g全部替换
//		var kwords=str.match(reg);
//		if(kwords!="null"){			//因为如果搜索的变量没有，会被返回空，以后可能出现null的都提前先判断一下
//		document.write(kwords);  //输出No,no
//		document.write("共替换了"+kwords.length+"处");
//		}
//查找  str.searh();
//和indexOf相同，但是不支持模式查找
//	var index=str.search(reg)  和indexOf完全相同
//search是indexOf的模式查找版
//正则表达式
//why？字符串中字符出现的规律
//作用：验证字符串格式，查找关键字，替换关键字
//1，选择符号:[所以备选字符]
//一个[]，只能代表一类字符
//1[123] 表示12,11,13
//1[^123] 表示1和除了123都行
//-符号，备选字符的连续范围[1-9]表示1-9
//[a-zA-Z0-9]->\w  字母数字匹配  
//[0-9]->\d 匹配数字
//空字符  /s
//字符出现的两次{min,max}  num是固定长度  min最小长度，max最大长度

//RegExp对象:js中专门疯转一条正则表达式，提供使用正则表达式的常用API
//在使用正则表达式时，必须创建RegExp
//创建正则表达式:var RegExp=/正则表达式/ig;
//RegExp的方法
//	test()检索字符串中指定的值，返回true或者false;影响lastIndex属性值
//	API:var boolean=regExp.text("被检查的字符串");     //返回true或者false；
//	验证和查找的区别:验证要求完整匹配，查找要求部分匹配
//	var regExp=/\w+@\w+([-]\w+)*(\.\w+)+/;
//	var regExp=  /^\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+[A-Za-z]{2,14}$/;  
//	//验证邮箱    这个开头添加了^和最后添加了$可以匹配dhwe@jdu@iws.com是错误的
//	var regExp=  /\w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\.)+[A-Za-z]{2,14}/; 
//	//验证邮箱，这个开头没有加^和最后没有加$,如果用户输入dhwe@jdu@iws.com是可以通过的
//正则表达式		贪婪模式:.+.* 默认先匹配整个字符串，在缩小
//正则表达式 	懒惰模式：(.+?) (.*?),从第一个字符开始，向后扩展范围
//匹配超链接的正则表达式:<a(.+?)href="(.*?)"(.*?)>
//凡是正则表达式里面的斜线都变成双斜线  程序运行时，单斜线和双斜线是一样的
//	while(true){
//		var input=prompt("输入邮箱");
//		if(regExp.test(input)){
//			document.write("可以使用");
//			break;
//		}else{alert("格式错误")};
//	}
//查找:exec:查找关键字的位置，又能找到关键字的内容，indexOf不支持正则，search支持正则，只能match所以内容，但是找不到位置
//需求：找到静静和明明的位置 
// regExp.exec("被查找的内容");
//查找:仅判断有没有，或者仅查找位置:indexOf()  ,支持正则表达式secrch()
//		仅找所有的关键字内容:match()
//		即找位置，又找内容:exec()
// 	var str="明明喜欢我，却不告诉我，别理我，我想静静，静静是谁？"
// 	var regExp=/明明|静静/g;   //两个元素在全局查找
// 	var arr=[];
// 	while((arr=regExp.exec(str))!=null){
// 		document.write("在位置"+arr.index+"发现:"+arr[0]);
// 	}
//从正则表达式匹配内容中，取出一部分:RegExp();
//案例，在一个字符串中找出网址，并找出定位的网址内容
//	var txt='<script href="a.js"/>'+'<a href = "cost/list.do">链接一</a>'+
//	'<a class="main" href = "cost/add.do">链接二</a>';
//	var regExp=/<a(.+?)href\s*=\s*['"](.*?)['"](.*?)>/ig;
//	while((arr=regExp.exec(txt))!=null){
//		console.log(arr[0]);
//		console.log(RegExp.$2);  //不能小写，RegExp.$2取出第二个匹配的来，第二个匹配(.*？)  正则表达式的第n个分组
//		//正则表达式时从1开始匹配
//		//必须通过RegExp类型，直接调用$n,不能使用对象
//	}

//用replace方法替换字符串中匹配的字符
//	var str="那天我去了她家，我说，我草";
//	str=str.replace(/我[去草]/g,"**");  //正则表达式匹配我去,我草
//	document.write(str);
//输出:那天**了她家，我说，**
//split可以使用正则表达式，
//	var str="no zuo no   die";
//	var words=str.split(/\s+/);       //一个空格，两个空格都可以
//	for(var i=0;i<words.length;i++){
//		var frist=words[i][0].toUpperCase(1);
//	}
//document.write(words.join(" "))
//去除一个字符串开头或者结尾的空白字符
//.trim可以去除开头或者结尾的空格，中间的去不了
//对输入字符串的处理多数先清除开头或者结尾的空格在做处理
//判断用户说输入是否和数据库中一致
//.trim只有ie8不支持
//所有的string API都需要变量保存结果
//一常规做法
//	var code="haod"
//	input=prompt("请输入验证码");
//	input=input.trim();
//	if(input==code){
//		document.write("登录成功");
//	}else(
//		document.write("登录失败")
//	)
//二，使用正则表达式封装
//	var code="haod";
//	while(true){
//		var input=prompt("输入验证码");
//		if(quchu(input).toLowerCase()==code.toLowerCase()){
//			document.write("登录成功");
//			break;
//		}else{
//			alert("验证码错误");
//		}
//	}
//	function quchu(str){
//		//使用正则表达式去掉开头和结尾的空字符
//		var regExp=/(^\s+)|(\s+$)/g;
//		str=str.replace(RegExp,"");
//		return str;
//	}

//Math类型  :封装了数学计算中的API
//Math不能实例化，不能new
//Math.round(num)  四舍五入取整数
//Math.ceil(num)   向上取整  例如：15.4    16
//Math.floor(num)  向下取整  例如：15.4    15
//Math.abs(num)	   取绝对值
//Math.max/min()  (值1，值2，值3输出最大或者最小)
//	var n=22.16;
//	Math.round(n)   22
//	Math.ceil(n)    23
//	Math.ceil(n)    22
//	var s1=75;
//	var s2=90;
//	var s3=80;
//	document.write(Math.max(s1,s2,s3)); //输出90
//	var arr=[2,3,4,6,7,8,9,2,3,4];
//	var max=Math.max.apply(Math,arr); //数组中是最快的速度
//	document.write("<br>"+arr+"最大"+max);
//
//随机数:Math.random():0<=r<1
//任意区域之间的随机数
//Math.floor(Math.random()*(max-min+1)+min)

//随机生成一个四位或者六位的随机验证码
//将所有的字母，数字装入一个数组备用
//	var codes=[];
//	//数字48-57 
//	for(var i=48;i<57;codes.push(i),i++);
//	//大写字母65-90
//	for(var i=65;i<=90;codes.push(i),i++);
//	//小写字母97-122
//	for(var i=97;i<=122;codes.push(i),i++);
//	var arr=[];
//	for(var i=0;i<4;i++){
//		//从0-61之间取随机数
//		var index=Math.floor(Math.random()*(61-0+1)+0);
//		var char=String.fromCharCode(codes[index]);  //每生成一个字符转换成一个code字符，然后压入arr中
//		arr.push(char);
//	}
//	var code=arr.join(""); //字符串拼接
//	document.write("你生成的四位随机数为："+code);
//	var input=prompt("请输入四位验证码 : "+code);
//	if(input==code){
//		alert("验证码正确");
//	}else{
//		alert("验证码不正确");
//	}
//	document.write("你生成的四位随机数为："+code);

// Date对象  封装一个时间点事件，并且提供对时间或者日期的API
//var date=new Date()  办了两件事:1，创建Date类型对象，2，自动获得浏览器的当前时间点
//Date对象中保存的是1970年1月1日0 0 0 0 0到现在的毫秒数
//	var data=new Date(0);
//	console.log("<br>"+data);
//	var data1=new Date();
//	console.log("<br>"+data1);
//	var data2=new Date("<br>"+"1994-12-04");
//	console.log("<br>"+data2);
//	var month=now.getMonth();
//	console.log(month);
//天数加3天
	//先取出分量，做加减，再set回去
	//获取时间get
	//设置时间set 特点：直接修改原日期对象，自动调整进制
//	var now=new Date("1982-06-09");
//	var next=new Date(now.getTime());
//	var d=next.getDate();
//	d-=15;
//	next.setDate(d);
//	console.log(now);
//	console.log(next);

//小明2012年6月29日入职
//卖身契3年，求合同的到期日期
//到期前一个月要续签，求续签的日期
//提前一周提醒，求提醒的日期
//如果续签日是周末，则提前到周五
//.toLocaleDateString()是将时间简化版
//可以将Fri May 22 2015 00:00:00 GMT+0800 (中国标准时间)
//转化为 2015/5/22
//	var hire=new Date("2012-6-30");
//	hire.setFullYear(hire.getFullYear()+3);
//	document.write("合同的到期日是:"+hire.toLocaleDateString());
//	hire.setMonth(hire.getMonth()-1);
//	document.write("<BR>合同的到期提前一个月是:"+hire.toLocaleDateString());
//	if(hire.getDay()==6){//如果是周六
//		//减少一天
//		hire.setDate(hire.getDate()-1);
//	}else if(hire.getDate()==0){
//		hire.setDate(hire.getDate()-2); //减少两天
//	}
//	document.write("<br>续签时间:"+hire.toLocaleDateString());
//	hire.setDate(hire.getDate()-7); 
//	document.write("<br>提前一周提醒时间:"+hire);

//输出当前时间格式2017年11月26日 星期日上午11:17:02，进行自动判断
//	function format(data){
//		var week=['日','一','二','三','四','五','六'];
//		var y=data.getFullYear()+"年";
//		var m=data.getMonth()+1+"月";
//		var d=data.getDate()+"日";
//		var w=" 星期"+week[date.getDay()];
//		var h=date.getHours();
//		var am=date.getHours()>=12?"下午":"上午";
//		h=h>12?h-12:h;  //如果时间超过12点，则13-12是一点，否则输出h
//		h=h<10?"0"+h:""+h;  
//		//如果是一位的，则添加一个0变成两位
//		var mi=data.getMinutes();
//		mi=mi<10?"0"+mi:""+mi;  //分钟
//		var s=data.getSeconds();
//		s=s<10?"0"+s:""+s;  //分钟
//		var str=y+m+d+w+am+h+":"+mi+":"+s;
//		return str;
//	}
//	var date=new Date()
//	document.write(format(date));
//	//输出2017年11月26日 星期日上午11:17:02

//Number对象
//Number对象表示数值数据和数字常数，主要用于对数字进行指定格式的输出
//var num=new Number(5);		5
//var num=new Number("1.5");	1.5
//var num=new Number();			0
//var num=new Number("hello");	nan
//var num=new Number('123abc');  nan
//将数据转换为Number数据类型
//var num=Number(5);		5
//var num=Number("1.5");	1.5

//Boolean对象表示布尔值对象true或者false

//错误处理:导致程序运行停止的运行时异常状态
//什么是错误处理，在出现异常状态时，保证程序不停止的机制
//ECMA定义了六种错误类型
//	EvalError
//	RangRrror  参数超出范围
//	ReferenceError 引用错误，找不到对象
//	SyntaxError	 语法错误，自己修改源代码
//	TypeError	错误的使用了类型和类型的方法
//	URLError
//	如何处理错误
//try{
//	可能出错的代码
//}catch(err){
//	只要抛出错误,都会创建一个Error对象
//	错误处理的代码
//	1.获得错误信息:err.name类型
//	感觉错误类型,执行不同的处理
//}finally{
//	无论是否出错,都必须执行的代码
//}

//Function
//在JavaScript中，函数也是以对象的形式存在的，每个函数都是一个function对象实例
//1.以声明方式定义方法，
//	function 方法名(参数列表){
//		方法体;return 返回值
//}
//2.以创建对象的方法定义方法
//var 方法名=new Function("C参数1"，-----方法一；return 返回值)
//只有声明方式的定义方法才被提前解析
//比较大写，按照升序来比较
//第一种方式定义function
//	function compare(a,b){
//		return a-b;
//	}
//第二种方式定义function
//	var compare=new Function("a","b","return a-b;"); //Function必须大写
//	var arr=[1,22,33,45,232,4343,,335];
//	arr.sort(compare);
//	document.write(arr);
//第三种 匿名函数  定义是没有指定名称的函数
//匿名函数的两个用途
//1，回调函数 	 函数何时执行，程序员不需要控制，由所在环境自动调用控制
//	比如:比较器就是回调函数
//	var arr=[2,34,5,5,6,7,88,87,3];
//	arr.sort(function(a,b){return a-b;});
//	document.write(arr);   
	//一样可以输出的
//2，自调函数   匿名函数自己调用自己
//当函数不需要重复使用的时候，使用自调函数，
//var compare=function(a,b){return a-b;}
//笔试题 js中方法定义的几种方式
//2,3必须写在使用之前
//1，function compare(a,b){return a-b;}
//2,var compare=function(a,b){return a-b;}
//3,var compare=new Function("a","b","return a-b;");
//重载:方法，根据传入的参数列表不同，执行不同的任务
//例如：function jz(money){
	//现金结账，验钞，找零
//
//		}
//		function jz(cardId，pwd){
	//刷卡结账:验证卡号，验证密码
//}
//用一个方法名可以自动判断并提供多个功能，但是js中的function不能重名
//js语法根本不支持重载，但是可以去模拟。自动创建，直接使用
//arguments对象:方法对象中保存所有参数的类数组对象类数组对象：长得像数组的对象
//有length属性，但是有下标，类似数组，可以当数组用，但是不是数组，模拟的
//arguments案例，是在及其特殊的情况下使用的，一般不适用
//	function calc(){	//calc()里面可以不用写东西
//		//arguments是默认隐藏的
//		if(arguments.length==1){
//			var a=parseInt(arguments[0]);
//			var b=parseInt(arguments[1]);
//			alert(a*a);
//		}else{
//			var a=parseInt(arguments[0]);
//			var b=parseInt(arguments[1]);
//			alert(a+b);
//		}
//	}
	//html 部分
//	<button onclick="calc(13)">算平方</button>
//	<button onclick="calc(13,14)">算加法</button>

//使用匿名函数去掉左边空格
//	var ltrim=function(str){
//		var reg=/^\s+/;
//		return str.replace(reg,"");
//	}
//使用匿名函数去掉右边的空格
//	var rtrim=function(str){
//		var reg=/\s+$/;
//		return str.replace(reg,"");
//	}

//JS闭包()  重要，笔试经常会用到
//变量作用域  是程序中定义这个变量的区域
//	全局变量拥有全局作用域
//	局部变量(函数内的变量)，其作用域是局部性的
//函数作用域
//	变量在声明他的函数体以及这个函数体内嵌套的任何函数体内都是有定义的
//	任何一段JavaScript代码都对应一个作用域链
//		作用域链中科院存放一系列对象，代码中声明的变量将作为对象的属性存放
//	当需要使用一个变量时，将从作用域链中逐个查找对象的属性
//		比如要使用变量a，将先查找作用域中的第一个对象是否有属性a，如果有就使用，
//		如果没有就查找作用域链中下一个对象的属性，以此类推
//	作为JavaScript的顶层代码，其作用域链中只有一个对象即全局对象
//	作用域链都是从下面网上面找
//	对应浏览器客户端而言就是windows
//作用域后续
//	每当一个函数被调用时，会创建一个上下文对象(环境)，在该函数中声明局部变量将作为该上下文对象的属性存放
//	对应于函数中的代码段，其作用域链中将存放两个对象
//		第一个是调用该函数时创建的上下文对象
//		第二个是全局对象
//	在函数段代码中使用变量时将首先在该上下文对象的属性中查找，如果找不到则在全局对象windows中查找
//	当函数调用完成后，如果没有其他引用指向为此调用所创建的上下文对象，该对象将被回收
//调用方法创建3个对象
//方法的运行环境对象，不保存任何东西
//方法的活动对象，保存所有的局部变量
//方法的作用域链对象，保存所有可用变量所在对象的地址
//示例如下
//	var n=0;
//	function  getUnique(){
//		return n++;
//	}
//	console.log(getUnique());
//	console.log(getUnique());
//	console.log(getUnique());
//	console.log(getUnique());
//输出:0 1 2 3
	//如果编写时又写了一下n=0；效果如下
//	n=0;
//	console.log(getUnique());
//	console.log(getUnique());
//	console.log(getUnique());
//继续输出0 1 2 3 0 1 2 3 他还从头开始
//闭包 	该函数能使用函数外定义的变量
//函数外使用了不属于自己的局部变量
//闭包一
//	var n;
//	function fn(){
//		var b="b";
//		n=function(){
//			return b;
//		}
//	}
//闭包示例二
//	function counter(){
//		var n=0;
//		function getUnique(){
//			return n++;
//		}
//		return getUnique;
//	}
//	var c=counter();
	//c=null;//释放闭包占用的资源	
	//c不是赋值，而是方法，()是调用方法的案例
//	console.log(c());
//	console.log(c());
//	n=0;//设置n=0也是无效的
//	console.log(c());
//	console.log(c());
//	c=null;
//释放闭包占用的资源
	//输出0 1 2 3
//什么情况下使用:保护局部变量
//闭包应用的特征
//	1.局部变量
//		在函数中定义有共享意义如:缓存，计时器等，的局部变量，
//		注意:定义成全局变量会对外造成污染
//	2.内嵌函数
//		在函数f中声明有内嵌函数，内嵌函数g对函数f中的局部变量进行访问
//	3.外部使用
//		函数f在向外返回此内嵌函数g，外部可以通过此内嵌函数持有并访问声明函数f中的局部变量
//		而此变量在外部四通过其他途径无法访问的
//闭包自己联系
	function one(){
		var n=0;
		function two(){
			return n++;
		}return two;
	}
	var c=one();
	console.log(c());
	console.log(c());
	console.log(c());
	console.log(c());
	</script>

	</head>
	<body>
	</body>
</html>
